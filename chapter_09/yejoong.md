# 페이징이란
- 가상 주소 공간을 고정 크기의 페이지(page) 단위로, 물리 메모리를 동일한 크기의 프레임(frame) 단위로 분할하여 매핑(mapping)하는 기법
- 프로그램은 연속적인 논리 주소 공간처럼 동작하지만, 하드웨어의 MMU(Memory Management Unit)와 페이지 테이블(page table)을 통해 각 페이지 번호를 해당 프레임 번호로 변환하여 실제 물리 메모리에 접근

# 페이징에서의 세부사항
* 보호
    * 보호 비트: 각 페이지 프레임에는 읽기·쓰기·실행 권한을 지정하는 보호 비트(protection bits)가 있어, 코드·데이터·스택 등의 영역별 접근 권한을 강제합니다 
    * 유효/무효 비트: PTE(Page Table Entry)에 valid–invalid 비트를 두어 해당 페이지가 프로세스의 주소 공간에 속하는지를 표시합니다. 무효 페이지 접근 시 페이지 폴트가 발생하여 OS가 예외 처리하도록 합니다 


* 공유 페이지
    * 코드 공유: 여러 프로세스가 동일한 물리 페이지를 매핑하여 읽기 전용(reentrant, 재진입 코드) 코드 영역을 공유할 수 있습니다. 이를 통해 메모리 사용량을 크게 줄이고, 공통 라이브러리 등을 효율적으로 활용합니다 
        * reentrant 코드는 자체 수정 할 수 없는 코드, 실행 중에 절대 변경 없음. => 두개이상의 프로세스가 동일한 코드 동시에 실행 가능함.
        * 각 프로세스에는 자신의 실행을 위해 데이터 보유 위한 자체 레지스터 사본 & 데이터 저장영역
    * 가상 주소 매핑 유연성: 공유 메모리 영역은 각 프로세스의 가상 주소에 동일하게 매핑하거나(포인터 직접 공유 가능), 서로 다르게 매핑하여 유연성을 확보할 수 있습니다

# 페이지 테이블의 구조(페이지 테이블 구성 방법)
* 계층적 페이징 : 페이지 테이블 자체가 다시 페이징됨
    * 다단계 페이지 테이블: 전체 페이지 테이블을 한 번에 메모리에 두지 않고, 외부·내부 등 여러 레벨로 분할해 필요한 부분만 로드하도록 합니다. 2단계, 3단계 이상의 계층을 사용해 대형 주소 공간도 효율적으로 관리합니다 
    * 예시: 32비트 주소에서 상위 페이지 번호로 외부 테이블을, 하위 페이지 번호로 내부 테이블을 인덱싱해 물리 프레임 번호를 찾습니다 

* 해시 페이지 테이블
    * 해시 기반 매핑: 64비트 이상처럼 주소 공간이 넓을 때, 가상 페이지 번호를 해시하여 해시 테이블(bucket)에 저장합니다. 동일 해시값 충돌은 연결 리스트로 관리하며, 비교를 통해 일치하는 엔트리를 찾아 물리 프레임을 얻습니다 
    * 장점: 전체 페이지 테이블을 포워드 매핑하지 않고도 필요한 부분만 검색하므로, 메모리 절약 및 대규모 주소 공간에서 유리합니다 

* 역 페이지 테이블
    * 프레임 기준 엔트리: 전통적 프로세스별 페이지 테이블 대신 물리 메모리 프레임마다 하나의 엔트리를 두고, 그 프레임에 매핑된 (프로세스ID, 가상 페이지번호)를 저장합니다 
    * 트레이드오프: 페이지 테이블 크기를 물리 메모리 크기에 비례해 크게 줄이지만, 직접 인덱싱이 불가능해 해시 테이블이나 TLB를 결합해 검색해야 하므로 변환 속도가 다소 느려질 수 있습니다 

* Oracle SPARC Solaris
    * 해시 기반 구조: Solaris on SPARC 플랫폼은 완전 해시 기반 페이지 테이블을 채택하며, 커널용과 사용자용 2개의 해시 테이블을 운용합니다. 각 해시 엔트리는 연속된 가상 페이지 영역(contiguous span)을 베이스 주소(base)와 페이지 수(span)로 표현합니다 
    * TLB Miss 처리: 하드웨어는 먼저 TSB(Translation Storage Buffer)에 캐시된 TTE(Translation Table Entry)를 검색하고, 없으면 커널이 해시 테이블에서 해당 엔트리를 찾아 TSB와 TLB에 채워 주소 변환을 완료합니다 


# 스와핑
