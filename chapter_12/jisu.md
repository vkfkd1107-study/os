# I/O 시스템
---
## 1. 중요한 이유
- 컴퓨터로 작업하려면 키보드, 마우스, 화면출력, USB파일 저장등의 외부 장치와의 상호작용이 필요
- CPU와 메모리가 빨라도, 외부장치가 느리면 전체 시스템 속도는 그 장치에 맞춰짐. I/O시스템은 컴퓨터에서 가장 느려서, 효율적으로 관리하는게 중요하다
---
## 2. I/O 하드웨어
### 다양한 장치
- **저장장치**: HDD, SSD, USB 등 데이터 영구저장장치
- **전송장치**: 네트워크 카드(인터넷 연결), 블루투스 등 데이터를 주고받는 통로
- **사람-인터페이스 장치**: 키보드, 마우스, 화면, 오디오 등 사용자와 직접 상호작용

### 버스
- 컴퓨터 내부에서 데이터가 이동하는 통로
- CPU, 메모리, 장치들이 버스를 통해 데이터를 주고받음

### 장치 컨트롤러
- I/O 장치의 전담 관리자
- 장치 특유의 복잡한 작업을 대신 처리하여, CPU는 중요한 작업에 집중할 수 있다
- 예) 데이터 블록 123을 가져오라: 장치 컨트롤러는 하드웨어가 이해하는 낮은 수준의 명령으로 변환

### I/O포트 및 메모리 I/O
- CPU가 장치 컨트롤러와 소통하는 방법
- 특정 메모리 주소(I/O 포트)에 데이터를 쓰거나 읽어서 장치 제어

### 인터럽트
- 장치가 작업을 마치면 CPU에 알리는 신호
- CPU는 하던 일음 멈추고 알림(인터럽트)을 처리하고, 원래 작업으로 돌아감
- CPU가 장치 상태를 계속 확인하는 것(폴링)보다 더 효율적
- 예) 프린터가 인쇄를 마치면, CPU에 인터럽트를 보내서 인쇄완료를 알림

### 직접 메모리 접근(Direct Memory Access: DMA)
- 대량의 데이터를 전송할 때, CPU가 일일이 데이터를 옮기는 것은 비효율적임
- DMA 컨트롤러가 데이터 전송 작업을 대신 처리
- CPU가 데이터 전송을 지시하고, DMA 컨트롤러가 처리할동안 CPU는 다른 작업을 한다
---

## 3. 애플리케이션 I/O 인터페이스: 사용자와 프로그램의 요청처리

### 블록장치와 문자장치
- 블록장치: 데이터를 고정된 크기의 블록으로 읽고 쓴다
- 문자 장치: 한 문자씩 데이터를 주고받음

### 입출력(I/O) 방식
- 블로킹 I/O (Blocking I/O)
    - 프로그램이 I/O 작업 요청 시, 작업이 완료될 때까지 대기
    - 예) 식당에서 음식을 주문하고, 아무것도 안하고 기다리는 것
- 논블로킹 I/O (Non-Blocking I/O)
    - 프로그램이 I/O 작업 요청 후, 바로 다른 작업 계속함. 작업 완료 시, 시스템이 알림
    - 예) 식당에서 음식을 주문하고, 주문 후 다른 일을 하다가 음식이 나오면 직원이 알려주는 것
    - 동시 작업에 유리

### 동기 쓰기 VS 비동기 쓰기
- 동기 쓰기
    - 데이터를 저장하라고 명령하면, 저장이 완료될때까지 기다림
    - 중요한 데이터(은행 거래 기록) 다룰 때 안정성이 높음
- 비동기 쓰기
    - 데이터를 저장하라고 명령하면, 일단 메모리(캐시)에 저장후 바로 다른 작업을 계속함
    - 실제 저장은 나중에 이뤄짐
    - 속도 빠름, 전원 off시 데이터 손실 위험 있음

---

## 4. 커널 I/O 서브시스템: I/O 지휘자
- 버퍼링
    - 장치들이 서로 다른 속도를 가졌기때문에, 데이터를 원활하게 주고받기 위한 임시 저장공간
    - 느린 네트워크에서 데이터를 받아 빠른 디스크에 저장할때, 중간에 버퍼를 두어 데이터를 모았다가 한번에 디스크에 쓴다
- 캐싱
    - 자주 접근하는 데이터 사본을 빠른 메모리(캐시)에 저장하여 필요할때 빠르게 가져옴
    - 본래 데이터를 다른 곳에 존재, 캐시는 사본을 가지고 있음
- 오류 처리(Error Handling)
    - I/O장치나 전송 과정 중 발생가능한 다양한 오류 대비
    - 디스크에서 데이터를 읽다가 오류가 나면 다시 시도해보고, 여러번 실패하면 오류 보고
- 전원 관리(Power Management)
    - 사용하지 않는 장치를 절전모드로 전환하여 에너지 전환
- I/O 요청 생애주기
    - 애플리케이션이I/O 요청을 하면, 장치드라이버, 컨트롤러를 거쳐 하드웨어에서 처리되고 완료되면 다시 돌아오는 과정을 거침
    - 많은 단계와 CPU가 필요하지만, 각 단계에서 효율적이게 설계됨
