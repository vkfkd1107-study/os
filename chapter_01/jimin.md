# 인터럽트

- 하드웨어 장치나 소프트웨어에서 예외 상황이나 특정 이벤트가 발생했을 때, 이를 CPU에 신호로 알려 현재 작업을 중단하고 해당 이벤트를 우선적으로 처리하도록 하는 메커니즘
- 운영체제가 동작할 수 있게 하는 핵심적인 역할

## 종류

### 호출 주체

- 하드웨어 인터럽트
- 소프트웨어 인터럽트 (Trap)
    - Exception : 소프트웨어 오류
    - System call : 소프트웨어 실행 도중 커널 서비스를 사용해야 하는 경우

---

| 유형               | 특징                                  | 예시                          |
|--------------------|---------------------------------------|-------------------------------|
| **하드웨어 인터럽트** | 비동기적, 외부 장치 발생              | 키보드 입력, 타이머 만료 |
| **소프트웨어 인터럽트** |                                   |                               |
| - System call        | 동기적, 의도적 호출                   | 파일 읽기 요청         |
| - Exception  | 비동기적, 프로그램 오류               | 0으로 나누기, 메모리 주소 오류|

### 무시 / 지연 가능 여부

- 마스크 불가능 인터럽트(non-maskable interrupt)
    - 인터럽트 마스크(mask, 저지)에 영향을 받지 않음
    - 가장 우선순위가 높은 인터럽트
    - 하드웨어 장애, 정전 사태 등 급박한 상황에서만 발생
    - 별도의 전기 신호를 사용해 처리
- 마스킹 가능 인터럽트(maskable interrupt)
    - 무시 / 비활성화가 가능한 인터럽트
    - 마스킹 여부를 이용해 소프트웨어에서 무시할 수 있음
    - 디바이스 컨트롤러가 서비스를 요청하기 위해 사용

## 동작 방식

1. 필요에 의해 CPU에게 인터럽트 신호 전달 
2. 전달된 인터럽트 신호는 CPU 인터럽트 요청 라인에 명시
3. 인터럽트 발생 시 명시적으로 현재 상태 저장 
4. 인터럽트 벡터를 통해 처리할 인터럽트 체인에서 해당 인터럽트를 처리할 수 있는 인터럽트 핸들러 캐치 후 디스패치
5. 복귀하기 전 상태 복원 
6. 인터럽트에 의해 중단되었던 연산 진행

## 구성 요소

- 인터럽트 핸들러
    - 발생한 인터럽트를 해결할 수 있는 로직
    - 다음과 같은 방식으로도 표현
        - 인터럽트 서비스 루틴
        - 인터럽트 처리 루틴
        - 인터럽트 취급 루틴
        - 인터럽트 처리기
        - 인터럽트 핸들러 루틴
- 인터럽트 벡터, 인터럽트 벡터 테이블
    - 인터럽트 핸들러의 위치를 인터럽트 벡터 테이블에 테이블 형식으로 관리
- 인터럽트 체인
    - 인터럽트 벡터 테이블이 가질 수 있는 크기보다 인터럽트 핸들러의 개수가 더 많음
    - 인터럽트 테이블의 오버헤드와 단일 인터럽트 핸들러로 디스패치하는 비효율성 사이의 절충안 제공
- 인터럽트 컨트롤러 하드웨어
    - 인터럽트 처리 연기
    - 적절한 인터럽트 핸들러로 디스패치
    - 인터럽트 간 우선순위 적용
- 인터럽트 요청 라인(Interrupt Request Line, IRQ)
    - 하드웨어 장치가 CPU에게 특정 이벤트가 발생했음을 알려주는 신호
    - CPU는 명령 처리 전 인터럽트 요청 라인을 항상 확인 

## 예시 

### xv6

```perl
#!/usr/bin/perl -w

# Generate vectors.S, the trap/interrupt entry points.
# There has to be one entry point per interrupt number
# since otherwise there's no way for trap() to discover
# the interrupt number.

print "# generated by vectors.pl - do not edit\n";
print "# handlers\n";
print ".globl alltraps\n";
for(my $i = 0; $i < 256; $i++){
    print ".globl vector$i\n";
    print "vector$i:\n";
    if(!($i == 8 || ($i >= 10 && $i <= 14) || $i == 17)){
        print "  pushl \$0\n";
    }
    print "  pushl \$$i\n";
    print "  jmp alltraps\n";
}

print "\n# vector table\n";
print ".data\n";
print ".globl vectors\n";
print "vectors:\n";
for(my $i = 0; $i < 256; $i++){
    print "  .long vector$i\n";
}

# sample output:
#   # handlers
#   .globl alltraps
#   .globl vector0
#   vector0:
#     pushl $0
#     pushl $0
#     jmp alltraps
#   ...
#   
#   # vector table
#   .data
#   .globl vectors
#   vectors:
#     .long vector0
#     .long vector1
#     .long vector2
#   ...
```

- 인터럽트 벡터 등록 로직

### linux

```c
struct irq_desc {
    irq_flow_handler_t handle_irq;
    unsigned int status_use_accessors;

    ...
};
```

- 인터럽트 체인 구조체
  - irq_flow_handler_t handle_irq : 인터럽트 체인 내 핸들러 함수 포인터 저장
  - status_use_accessors : 커널 내부에서 인터럽트 체인임을 식별하기 위해 사용

```c
struct irq_common_data {
    void *handler_data;
};
```

- irq_data 내부 필드
  - 디바이스 별 컨텍스트 저장
  - 인터럽트 핸들러가 디바이스 별 컨텍스트에 접근하기 위해 사용

```c
void irq_set_chained_handler_and_data(unsigned int irq, 
                                     irq_flow_handler_t handle,
                                     void *data)
{
    struct irq_desc *desc = irq_get_desc_buslock(irq, &flags, 0);
    desc->irq_common_data.handler_data = data;
    __irq_do_set_handler(desc, handle, 1, NULL);
}
```

- 특정 IRQ에 인터럽트 핸들러를 인터럽트 체인에 등록하기 위해 사용

```c
for (i = 0; i < gc->irq.num_parents; i++) {
    irq_set_chained_handler_and_data(gc->irq.parents[i], 
                                    gc->irq.handler, 
                                    gc);
}
```

- 인터럽트 체인 등록 예시

```c
static void gpio_irq_handler(unsigned int irq, struct irq_desc *desc) {
    struct gpio_chip *gc = irq_desc_get_handler_data(desc);
    unsigned long pending;
    
    pending = readl(gc->reg_base + GPIO_DATA_IN);
    for_each_set_bit(bit, &pending, gc->ngpio) {
        int child_irq = irq_find_mapping(gc->irq.domain, bit);
        generic_handle_irq(child_irq);
    }
}
```

- 디바이스 별 컨텍스트를 추출해 인터럽트 체인에 등록한 인터럽트 핸들러 호출