## 6.2. 임계구역 문제(The critical-setion problem) 
: 임계구역 안에서는 적어도 하나 이상의 다른 프로세스와 공유하는 데이터에 접근하고 갱신할 수 있다.
* 한 프로세스가 자신의 임계구역에서 수행하는 동안에는 다른 프로세스들은 그 임계구역에 들어갈 수 없다
* 해결안
    | 공유 자원을 안전하게 사용하기 위한 최소한의 약속

    * 상호 배제: 한 번에 하나씩만 사용하자.
    * 진행: 사용하려는 프로세스들끼리 신속하게 다음 사용자를 결정하자.
    * 한정된 대기: 기다리는 프로세스가 무한정 기다리지 않도록 공평한 기회를 주자.

1. Peterson 의 해결안

들어가고 싶다는 **의사(flag)**를 먼저 표현하고, 그럼에도 불구하고 상대방에게 **차례(turn)**를 양보하는" 방식
* 임계구역과 나머지 구역 번갈아 실행하는 2개 프로세스
* 두 프로세스가 두개의 데이터 항목을 공유
```shell
# 프로세스 i 의 관점
do {
    #1. 진입 의사 표시
    flag[i] = true;

    #2. 상대방에게 차례 양보
    turn = j;

    #3. 진입 조건 확인 (상대방이 진입 의사가 있음 && 현재 차례가 상대방일 경우 프로세스 i는 대기) - 만약 상대방이 진입의사 없음(flag[j] False)이면 루프 빠져나와 임계구역에 진입함.
    while (flag[j] && turn == j);

    # --- 임계 구역 (Critical Section) ---
    #       공유 자원 사용
    # 이 while 루프를 빠져나가면, 다른 프로세스는 진입조건에 의해 막혀 있기 때문에 프로세스 i는 안전하게 임계구역 코드를 실행함
    # ---------------------------------

    # 4. 진입 의사 철회
    flag[i] = false;

    # --- 나머지 구역 (Remainder Section) ---

} while (true);

```

3가지 조건 만족 여부 \
1. 상호 배제 (Mutual Exclusion): 두 프로세스가 동시에 임계 구역에 진입하려면 while 조건을 둘 다 통과해야 합니다. 만약 turn이 i와 j 값을 동시에 가질 수 없으므로, 둘 중 하나는 반드시 while 루프에서 대기하게 됩니다. 따라서 상호 배제가 보장됩니다.

2. 진행 (Progress): 임계 구역에 아무도 없고, 진입하려는 프로세스가 있다면 그 프로세스는 while 조건에서 flag[j]가 false이므로 즉시 통과하여 진입할 수 있습니다. 결정 과정이 무한정 연기되지 않습니다.

3. 한정된 대기 (Bounded Waiting): 프로세스 i가 while 루프에서 기다린다는 것은 turn이 j이기 때문입니다. 프로세스 j가 임계 구역을 사용하고 나오면 flag[j]를 false로 바꾸므로, 프로세스 i는 바로 진입할 수 있습니다. 즉, 상대방이 최대 한 번만 임계 구역을 사용하면 내 차례가 오므로 무한정 대기하지 않습니다.

* 멀티코어/ 멀티스레드 응용프로그램은 명령 순서 뒤바뀌면 데이터 일관성 깨짐

## 최적화: 왜 순서를 바꿀까? 🚀
컴퓨터는 코드를 더 빨리 실행하기 위해 두 가지 수준에서 코드 순서를 재정렬합니다.

* 컴파일러 재정렬: 컴파일러는 코드를 기계어로 번역할 때, 데이터 종속성이 없다면 더 효율적인 코드를 만들기 위해 명령어 순서를 바꿉니다.
* CPU 재정렬 (Out-of-Order Execution): 최신 CPU는 여러 명령어를 동시에 처리합니다. 만약 특정 명령어(예: 메모리에서 데이터 읽기)가 느리게 처리되면, CPU는 마냥 기다리지 않고 그 뒤에 있는, 상관없는 다른 명령어를 먼저 처리하여 작업 효율을 극대화합니다.
* 싱글 스레드 환경에서는 프로그램의 최종 결과에 영향 X

## 멀티코어 환경에서 왜 문제가 될까?
# 명령어 재정렬 문제와 메모리 배리어

## 문제점: 명령어 재정렬로 인한 데이터 불일치 💣

컴파일러나 CPU는 성능 최적화를 위해 서로 종속성이 없는 명령어의 순서를 바꿀 수 있습니다. 이로 인해 멀티스레드 환경에서 데이터 불일치 문제가 발생할 수 있습니다.

**시나리오**: 스레드 1(Writer)이 데이터를 쓰고 `ready` 플래그를 설정하면, 스레드 2(Reader)가 플래그를 확인하고 데이터를 읽습니다.

* **개발자 의도**
    1.  **Writer**: `data = 100;`
    2.  **Writer**: `ready = true;`
    3.  **Reader**: `while (!ready);`
    4.  **Reader**: `print(data);` // `100`을 읽음

* **실제 발생 가능한 재정렬**
    `data` 할당과 `ready` 할당은 종속성이 없으므로 순서가 바뀔 수 있습니다.

    1.  **Writer**: `ready = true;` (재정렬됨)
    2.  **Reader**: `while (!ready);` // `ready`가 `true`이므로 대기 종료
    3.  **Reader**: `print(data);` // `data`가 할당되기 전이라 **쓰레기 값**을 읽음
    4.  **Writer**: `data = 100;` (재정렬됨)

---

## 해결책: 메모리 배리어 (Memory Barrier) 🛡️

**메모리 배리어**는 코드의 특정 지점을 기준으로 명령어 재정렬을 금지하여 실행 순서를 보장하는 명시적인 장치입니다.

메모리 배리어는 컴파일러와 CPU에게 **"배리어 이전의 모든 메모리 작업이 완료되기 전까지, 배리어 이후의 메모리 작업을 실행하지 말라"**고 강제합니다.

### 수정된 코드

```c
// 스레드 1 (Writer)
data = 100;
memory_barrier(); // 이 지점을 기준으로 재정렬 금지
ready = true;

// 스레드 2 (Reader)
while (!ready);
memory_barrier(); // 이 지점을 기준으로 재정렬 금지
print(data);