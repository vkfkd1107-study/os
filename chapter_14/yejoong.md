# Chapter 14. 파일 시스템 구현

## 1. 파일 시스템 구조 (File‑System Structure)

### 간단한 정의
**파일 시스템 구조**는 컴퓨터에서 파일과 폴더를 체계적으로 저장하고 관리하기 위한 전체적인 틀
### 왜 필요한가?
저장장치는 블록 단위의 데이터 덩어리만 다룰 수 있기 때문에, 운영체제가
   - 파일 이름 → 디스크 블록 위치로 매핑
   - 접근 권한, 수정 시간, 파일 크기 같은 메타데이터 관리
   - 디렉터리 구조와 경로를 통해 파일을 체계적으로 정리
이런 기능을 제공해야 사용자가 편하게 파일을 다룰 수 있습니다.


| 구성 요소                                   | 설명                                               |
| --------------------------------------- | ------------------------------------------------ |
| **파일시스템 (File System)**                 | 저장장치를 논리적으로 관리하는 전체 시스템                          |
| **입/출력 제어층 (I/O Control)**              | 디바이스 드라이버와 하드웨어 제어를 담당                           |
| **기본 파일 시스템 (Basic FS)**                | 디스크 블록 단위의 입출력을 관리                               |
| **파일 구성 모듈 (File Organization Module)** | 파일을 블록에 어떻게 배치할지, 접근할지 결정                        |
| **논리 파일 시스템 (Logical FS)**              | 파일 이름, 권한, 구조 같은 메타데이터 관리                        |
| **파일 제어 블록 (FCB)**                      | 특정 파일에 대한 모든 메타데이터를 담은 자료구조 (Linux에서는 inode와 유사) |

linux 표준 파일 시스템 extended file system.

## 2. 파일 시스템 구현 (File‑System Implementation)

### 간단한 정의
**파일 시스템 구현**은 설계된 파일 시스템 구조를 실제로 작동시키는 구체적인 방법들입니다.

### 주요 구현 요소
- 부트 제어 블록 : 시스템이 파티션으로부터 운영체제를 부트시키는 데 필요한 정보( 한 파티션의 첫 번째 블록이다)
- 볼륨 제어 블록(슈퍼블록) : 볼륨의 블록 수, 블록 크기, 가용 블록 수와 포인터, 가용 FCB수와 포인터.
- 디렉터리 구조 : 파일을 조직화하는 데 사용 - UFS에서는 디렉터리 구조에 파일이름 및 해당 inode번호 저장
- 파일별 FCB : 파일의 메타데이터를 담는 자료구조, Linux의 inode와 동일한 개념
   - 파일 권한, 파일날짜(생성접근쓰기), 파일 소유자, 그룹, ACL, 파일 크기, 파일데이터 블록 /파일데이터블록 포인터


### 메모리 내 정보
- 파일시스템 관리, 캐싱으로 성능향상 위해
- 이 정보들은 마운트 시점에 적재되고, 파일시스템 동작 중에 갱신되며, 마운트 해제 시에 제거된다.
- 파티션 테이블, 메모리 내 디렉터리 구조, 범 시스템 오픈 파일 테이블, 프로세스별 오픈 파일 테이블, 버퍼.

### 새로운 파일의 생성
- 프로세스 -> 논리파일시스템 호출
   - 논리파일시스템은 '디렉터리 구조' 의 포맷을 알고 있다.
- 파일 시스템은 새로운 FCB를 할당(새로운 파일 생성 위해) 
- 디렉터리 파일(실제로는 특수한 파일)을 메모리로 읽음
- "새 파일 이름 → 새 FCB 번호" 매핑을 디렉터리에 추가
- 파일 시스템(디스크)에 다시 쓴다.
- 파일 시스템의 계층 구조에서 역할 분담;파일 이름을 받아서 실제 디스크 블록과 연결하는 과정은 파일 구성 모듈이 담당하며, 최종 입출력은 기본 파일 시스템과 I/O 제어층이 한다
   - 논리 파일 시스템: "test.txt 파일의 내용을 가져와!"
   - 파일 구성 모듈: "test.txt → inode 25번 → 블록 100, 101, 103에 저장됨" 계산


### 사용법
일단 새로운 파일 생성되면, 입출력을 위해 사용될 수 있다.
- 파일이 우선 반드시 오픈되어야 함
- open()시스템콜은 논리적 파일 시스템에 파일 이름을 넘겨준다.
- open()시스템콜은 우선 파일이 이미 다른 프로세스에 의해 사용 중인지 확인하기 위해 범 시스템 오픈 파일 테이블을 검색함
   - 사용 중이면, 기존 범 시스템 오픈 파일 테이블을 가리키는 프로세스별 오픈 파일 테이블 항목이 생성됨
   - 아니라면, 주어진 파일 이름을 디렉토리 구조에서 찾는다.(통상 메모리에 디렉터리구조 일부가 캐싱됨)
- 파일이 발견되면 FCB가 메모리내의 범 시스템 오픈 파일 테이블에 복사됨
- 범 시스템 오픈 파일 테이블은 FCB 저장+파일을 오픈한 프로세스의 수 저장

- 프로세스별 오픈 테이블 : 범 시스템 오픈파일테이블 항목에 대한 포인터 + 필드(파일안의 현재위치 포인터, 파일이 오픈된 접근 모드 포함)들 갖는 새로운 항목이 만들어짐
- open()시스템콜은 프로세스별 파일 시스템 테이블 내 해당 항목 포인터 찾아 돌려준다
- 이후 모든 파일연산은 이 포인터 통해 실행됨

- open() 호출 시 파일 이름 → FCB(inode) 매핑 작업이 한 번 일어남

- 그 후에는 파일 디스크립터(=오픈된 파일의 엔트리)만 사용하므로 파일 이름이 필요 없음

- 하지만, 같은 파일을 다시 open()할 때 검색 속도를 높이려고 파일 이름을 캐싱할 수 있다

- 프로세스가 파일을 닫을 때, 프로세스별 테이블 항이 삭제되며 범시스템 항목의 오픈계수는 감소
- 오픈했던 모든 사용자가 파일 닫으면 
   - 디스크 기반 디렉토리 구조에 업데이트된 파일 정보가 복사되며,
   - 범 시스템 오픈 파일 테이블에서 그 항목이 삭제됨
- 실제 데이터블록을 제외한 오픈 파일에 대한 모든 정보는 메모리 내에 존재
- 디스크 입출력 작업 줄일 수 있으면 어디에나 캐시 사용


## 3. 디렉터리 구현 (Directory Implementation)
- 디렉터리는 사실 파일 이름 → FCB(inode) 번호를 매핑하는 특수한 파일입니다.
- 이 매핑 정보를 어떤 자료구조로 저장할지에 따라 구현 방식이 달라집니다.
- 대표적으로 **선형 리스트(linear list)**와 해시 테이블(hash table) 방식이 있습니다.
✅ 1) 선형 리스트 (Linear List)
특징	설명
구조	디렉터리 엔트리를 배열처럼 순서대로 저장
검색 방식	파일 이름을 처음부터 끝까지 순차 검색 (O(n))
장점	구현이 간단하고 메모리 오버헤드가 적음
단점	파일 수가 많아지면 검색, 삽입, 삭제 속도가 느려짐

📌 예시 (디렉터리 엔트리)

| 버킷 0   | 버킷 1  | 버킷 2   |
| ------ | ----- | ------ |
| a.txt  | b.txt | c.txt  |
| ax.csv |       | car.js |


a.txt를 찾기 위해 처음부터 순차적으로 비교

삽입 시: 리스트 마지막에 추가

삭제 시: 엔트리를 지우고 뒤의 엔트리를 한 칸씩 당김




✅ 2) 해시 테이블 (Hash Table)
해시 함수: h(file_name) = 첫 글자 아스키값 mod 3

| 버킷 0   | 버킷 1  | 버킷 2   |
| ------ | ----- | ------ |
| a.txt  | b.txt | c.txt  |
| ax.csv |       | car.js |

a.txt → h("a")=0 → 버킷 0 검색

b.txt → h("b")=1 → 버킷 1 검색

ax.csv → h("ax")=0 → 버킷 0 체이닝


## 4. 할당 방법 (Allocation Methods)

**할당 방법**은 파일의 내용을 디스크에 저장할 때 공간 효율적으로, 접근속도를 빠르게하면서 공간을 배정할지 결정하는 방법

#### 1. 연속 할당 (Contiguous Allocation)
- **비유**: 전집을 한 서가에 순서대로 배치
- **장점**: 빠른 접근, 순차 읽기에 유리
- **단점**: 큰 파일을 위한 연속 공간 찾기 어려움

#### 2. 연결 할당 (Linked Allocation)
- **비유**: 책마다 "다음 권은 X서가에"라는 쪽지 첨부
- **장점**: 크기 제한 없음, 공간 효율적
- **단점**: 순차 접근만 가능, 쪽지 분실 위험

#### 3. 색인 할당 (Indexed Allocation)
- **비유**: 목차 카드에 각 권이 어느 서가에 있는지 기록
- **장점**: 빠른 직접 접근, 관리 편리
- **단점**: 색인 블록을 위한 추가 공간 필요

## 5. 가용 공간의 관리 (Free‑Space Management)

### 간단한 정의
**가용 공간 관리**는 디스크에서 사용하지 않고 있는 빈 공간을 추적하고 관리하는 방법입니다.

### 왜 필요한가?
- **공간 파악**: 어디에 빈 공간이 있는지 알기 위해
- **효율적 할당**: 새 파일을 저장할 최적의 위치 찾기 위해
- **단편화 방지**: 작은 빈 공간들의 낭비를 막기 위해

### 쉬운 비유: 주차장 관리
주차장에서 빈 자리를 관리하는 방식과 비슷합니다:

#### 1. 비트맵 방식
- **비유**: 주차장 전체 지도에 빈 자리는 0, 차 있는 자리는 1로 표시
- **장점**: 간단하고 빠른 검색
- **단점**: 큰 주차장일 때 지도가 커짐

#### 2. 연결 리스트 방식
- **비유**: 빈 자리들끼리 "다음 빈 자리는 저기"라고 연결
- **장점**: 빈 공간이 적을 때 효율적
- **단점**: 빈 자리 찾기 위해 여러 곳 확인 필요

#### 3. 그룹화 방식
- **비유**: 구역별로 빈 자리 개수를 관리
- **장점**: 큰 연속 공간 찾기 쉬움
- **단점**: 관리가 복잡

## 6. 효율과 성능 (Efficiency and Performance)

### 간단한 정의
**효율과 성능**은 파일 시스템이 더 빠르고 효과적으로 작동하도록 개선하는 다양한 기법들입니다.

### 왜 필요한가?
- **속도 향상**: 파일 접근 시간을 단축하기 위해
- **자원 절약**: CPU와 메모리를 효율적으로 사용하기 위해
- **사용자 만족**: 더 빠른 응답으로 사용자 경험 개선

### 쉬운 비유: 음식 배달 서비스
음식 배달 서비스의 효율성 개선과 비슷합니다:

#### 성능 향상 기법들
1. **캐싱 (Caching)**
   - **비유**: 자주 주문하는 음식은 미리 준비해두기
   - **효과**: 자주 사용하는 파일을 메모리에 보관

2. **동기/비동기 쓰기**
   - **동기**: 주문 완료 확인 후 다음 주문 받기
   - **비동기**: 주문 받자마자 다음 주문도 받기

3. **디스크 스케줄링**
   - **비유**: 배달 경로를 효율적으로 계획하기
   - **효과**: 디스크 헤드 이동을 최소화

4. **클러스터링**
   - **비유**: 비슷한 지역 주문들을 묶어서 배달
   - **효과**: 관련 파일들을 가까운 곳에 저장

## 7. 복구 (Recovery)

### 간단한 정의
**복구**는 시스템 오류나 정전 등의 문제가 발생했을 때 파일 시스템을 안전하게 이전 상태로 되돌리는 기능입니다.

### 왜 필요한가?
- **데이터 보호**: 중요한 파일을 잃지 않기 위해
- **시스템 안정성**: 오류 후 정상 작동을 보장하기 위해
- **사용자 신뢰**: 믿을 수 있는 시스템 제공을 위해

### 쉬운 비유: 자동차 보험과 블랙박스
자동차 사고에 대비하는 방식과 비슷합니다:

#### 복구 기법들
1. **백업 (Backup)**
   - **비유**: 자동차 보험 가입
   - **방법**: 정기적으로 중요 파일들을 다른 곳에 복사

2. **저널링 (Journaling)**
   - **비유**: 블랙박스로 운전 기록 저장
   - **방법**: 파일 변경 과정을 일기장에 기록

3. **스냅샷 (Snapshot)**
   - **비유**: 정기적으로 자동차 상태 사진 촬영
   - **방법**: 특정 시점의 전체 시스템 상태 저장

4. **일관성 검사**
   - **비유**: 사고 후 자동차 점검
   - **방법**: 시스템 재시작 시 파일 시스템 전체 검사

## 8. 예: WAFL 파일 시스템 (Example: WAFL File System)

### 간단한 정의
**WAFL(Write Anywhere File Layout)**은 NetApp에서 개발한 혁신적인 파일 시스템으로, 어디든 쓸 수 있는 유연한 구조를 가지고 있습니다.

### 왜 특별한가?
- **유연성**: 데이터를 어느 위치에든 자유롭게 저장 가능
- **효율성**: 빠른 스냅샷과 복제 기능
- **안정성**: 데이터 손실 없는 안전한 쓰기

### 쉬운 비유: 모듈러 건축
조립식 건물처럼 필요에 따라 자유롭게 구성할 수 있는 시스템:

#### WAFL의 주요 특징
1. **Write Anywhere**
   - **비유**: 빈 땅 어디에든 건물 증축 가능
   - **특징**: 빈 공간 어디든 데이터 저장 가능

2. **Redirect-on-Write**
   - **비유**: 기존 건물 건드리지 않고 새 곳에 증축
   - **특징**: 기존 데이터 수정하지 않고 새 위치에 저장

3. **효율적 스냅샷**
   - **비유**: 건물 설계도만 복사하면 전체 복제 완료
   - **특징**: 전체 복사 없이 빠른 백업 생성

4. **NVRAM 활용**
   - **비유**: 정전에도 사라지지 않는 설계도 보관함
   - **특징**: 정전 시에도 데이터 보호

### WAFL의 장점
- **스냅샷이 빠름**: 몇 초 안에 전체 시스템 백업
- **공간 효율적**: 중복 데이터 없이 저장
- **복구가 쉬움**: 언제든 이전 상태로 되돌리기 가능

## 요약 (Summary)

파일 시스템 구현은 마치 **대형 도서관을 효율적으로 운영**하는 것과 같습니다:

1. **구조 설계**: 전체적인 관리 체계 수립
2. **실제 구현**: 설계를 바탕으로 운영 시스템 구축
3. **목록 관리**: 각 서가의 책 목록을 효율적으로 관리
4. **공간 배치**: 책을 어떻게 서가에 배치할지 결정
5. **빈 공간 관리**: 사용하지 않는 서가 공간 추적
6. **성능 개선**: 더 빠르고 효율적인 서비스 제공
7. **복구 시스템**: 문제 발생 시 원상복구 방안
8. **혁신 사례**: WAFL처럼 새로운 접근방식 도입

현재 우리가 사용하는 모든 컴퓨터와 스마트폰에서 이러한 파일 시스템들이 보이지 않는 곳에서 열심히 작동하고 있으며, 덕분에 우리는 편리하게 파일을 저장하고 관리할 수 있습니다.