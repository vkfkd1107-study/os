# 동기화 예제
동기화: 프로세스 사이의 수행을 제어하는 것
1. 실행 순서 제어
2. 상호배제 (동시 접근 방지)

## 유한 버퍼 문제(생산자 소비자 문제)
: 생산자와 소비자가 공유 버퍼를 사용하여 데이터를 주고받는 문제
- 생산자: 데이터를 생산하는 프로세스
- 소비자: 데이터를 소비하는 프로세스
- 공유자원: 여러 프로세스가 접근할 수 있는 자원
- 임계구역: 공유자원에 접근하는 코드 영역
- 레이스 컨디션: 잘못된 실행으로 여러 프로세스가 동시에 공유자원에 접근하는 문제

```c
<!-- 공유하는 자료구조 -->
int n;                    // 버퍼의 크기 (예: 10개 슬롯)
semaphore mutex = 1;      // 상호배제를 위한 세마포어 (뮤텍스 역할)
semaphore empty = n;      // 빈 슬롯의 개수 (초기값: n개)
semaphore full = 0;       // 채워진 슬롯의 개수 (초기값: 0개)

// 생산자 프로세스
while (true) {
    wait(empty);          // 빈 슬롯이 있는지 확인 (없으면 대기)
    wait(mutex);          // 임계구역 진입 전 락 획득
    // 생산자 임계구역: 버퍼에 데이터 추가
    signal(mutex);        // 임계구역 락 해제
    signal(full);         // 채워진 슬롯 개수 증가
}

// 소비자 프로세스
while (true) {
    wait(full);           // 채워진 슬롯이 있는지 확인 (없으면 대기)
    wait(mutex);          // 임계구역 진입 전 락 획득
    // 소비자 임계구역: 버퍼에서 데이터 제거
    signal(mutex);        // 임계구역 락 해제
    signal(empty);        // 빈 슬롯 개수 증가
}
```

## Readers-Writers 문제
: 여러 프로세스가 공유 데이터를 읽거나 쓰는 문제

예) 하나의 DB를 여러 프로세스에서 읽고 쓰는 문제
읽기 작업은 동시에 접근할 수 있지만, 쓰기작업은 배타적인 접근이 필요함

```c

// 쓰기 작업
while (true) {
    // 쓰기 작업 전 락 획득
    wait(rw_mutex);
    // 쓰기 작업
    signal(rw_mutex);
}

// 읽기 작업
wait(mutex);           // read_count 보호용 뮤텍스
read_count++;
if (read_count == 1) {
    wait(rw_mutex);    // 첫 번째 리더가 rw_mutex 획득
}
signal(mutex);         // read_count 보호 해제

// 읽기 수행
// ...

wait(mutex);           // read_count 보호용 뮤텍스
read_count--;
if (read_count == 0) {
    signal(rw_mutex);  // 마지막 리더가 rw_mutex 해제
}
signal(mutex);
```

## 식사하는 철학자들 문제
: 여러 철학자가 공유 테이블에 앉아 식사하는 문제
철학자들이 식사를 하기 위해 서로 젓가락을 계속 대기하는 것을 상황으로 풀어낸것

### 해결책 1: 젓가락 순서 정하기
```c
// 짝수 번호 철학자: 왼쪽 → 오른쪽
// 홀수 번호 철학자: 오른쪽 → 왼쪽
if (id % 2 == 0) {
    wait(left_chopstick);
    wait(right_chopstick);
} else {
    wait(right_chopstick);
    wait(left_chopstick);
}
```

### 해결책 2: 최대 4명만 동시 식사
```c
semaphore room = 4;  // 최대 4명만 방에 들어갈 수 있음
wait(room);          // 방 입장
// 젓가락 획득 및 식사
signal(room);        // 방 퇴장
```

## 실제 사용 예시

### 유한 버퍼 문제
- 프린터 스풀러 시스템
- 네트워크 패킷 버퍼
- 생산라인 제품 버퍼

### Readers-Writers 문제
- 데이터베이스 시스템
- 파일 시스템
- 캐시 메모리 관리

### 식사하는 철학자들 문제
- 네트워크 리소스 할당
- 교착상태 방지 알고리즘
- 병렬 컴퓨팅 자원 관리


---
## 기본 동기화 기법

### Peterson's Algorithm
문제상황: 두 프로세스가 하나의 공유변수를 동시에 접근할때 어떻게 안전하게 보호할까?
=> 순서를 정해서 한번에 하나만 접근

### 하드웨어 동기화
SW로만 동기화하면 복잡하고 느림. CPU가 제공하는 명령어를 사용하면 더 빠르고 간단하게 동기화 가능
=> CPU가 한번에 처리하는 명령어여서 중간에 끊기지 않음
```c
boolean TestAndSet(boolean *target) {
    boolean rv = *target;    // 현재 값을 읽고
    *target = true;          // true로 바꾸고
    return rv;               // 원래 값을 반환
}

// 사용법
boolean lock = false;

// 프로세스가 락을 획득하려고 할 때
while (TestAndSet(&lock));  // lock이 false면 true로 바꾸고 들어감
// 임계구역 (안전하게 실행)
lock = false;               // 락 해제
```

### Monitor
세마포어는 복잡하고 실수하기 쉬움. 모니터는 더 쉽고 안전하게 동기화 가능
모니터
- 자물쇠가 달린 상자
- 한번에 하나의 프로세스만 들어갈 수 있음
- 안에 들어가면 자동으로 잠기고, 나오면 자동으로 열림
=> 프로그래머가 락을 직접 관리할 필요 없음. 모니터가 알아서 함


### [정리]
- Peterson: 소프트웨어로 순서를 정해서 안전하게 만드는 방법
- 하드웨어 동기화: CPU의 특별한 명령어로 빠르고 안전하게 만드는 방법
- 모니터: 프로그래머가 쉽게 사용할 수 있도록 도와주는 도구

---
## 대체 방안

### 트랜잭션 메모리
- DB트랜잭션과 유사
- 한 트랜잭션의 모든 연산이 완수되야 메모리 트랜잭션이 확정된다
- 병행성 프로그래밍에서 사용되는 기법

### OpenMP
- 공유 메모리 시스템에서 병렬 프로그래밍을 위한 API
- 병렬처리를 쉽게 할 수 있도록 해준다

### 함수형 프로그래밍 언어
- 가변상태를 허용하지 않으므로 경합조건, 교착상태를 피한다
