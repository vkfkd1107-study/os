# 8. 교착상태
정상적인 작동 모드에서 프로세스는 다음 순서로만 자원 사용할 수 있다.
1. 요청. 2. 사용 3. 방출

## 8.2. 다중스레드응용에서의 교착상태(Deadlock in Multithreaded Applications)
두 mutex 락이 생성되고 초기화됨
```
pthread_mutex_t first_mutex;
pthread_mutex_t second_mutex;

pthread_mutex_init(&first_mutex,NULL);
pthread_mutex_init(&second_mutex,NULL)
```
두 스레드(thread_one, thread_two) 생성되고 두 스레드는 mutex 락에 대한 접근 권한 갖는다
thread_one이 first_mutex획득하고, thread_two가 second_mutex 획득하면 교착상태 될수있다.

교착상태 가능하더라도, thread_two가 락을 획득하려고 시도 전에, thread_one이 first_mutex, second_mutex를 획득, 방출할 수 있다면 교착상태는 발생 않는다.

### 8.2.1. Live lock
* 라이브니스 장애
* 교착 상태와 유사하다.
    * 둘 다 두 개 이상의 스레드가 진행되는 것을 방해함
* 교착 상태 : 어떤 스레드 집합의 모든 스레드가 같은 집합에 속한 다른 스레드에 의해서만 발생할 수 있는 이벤트를 기다리면서 봉쇄되면 발생
* 라이브락 : 스레드가 실패한 행동을 계속해서 시도할 때 발생
    * 따라서 각 스레드가 실패한 행동 재시도하는 시간을 무작위로 정하면 회피 가능함

## 8.3. 교착상태 특성(Deadlock Characterization)
#### 필요조건들
1. 상호 배제(mutual exclusion) \
    : 최소한 하나의 자원은 비공유 모드로 점유되어야 하고 비공유 모드에서는 한번에 1스레드만 자원 사용가능(자원 요청 시 방출될 때까지 대기)
2. 점유하며 대기(hold-and-wait) \
    : 스레드는 최소 하나의 자원 점유한 채, 현재 다른 스레드에 의해 점유된 자원 추가로 얻기 위해 대기중
3. 비선점(no preemption) \
    : 자원 강제적 방출 불가하고, 점유하고 있는 스레드에 의해 자발적으로 방출만 가능
4. 순환 대기(circular wait) \
    : 대기 스레드 집합이 서로 자원 대기하는 것은 순환적..

#### 자원 할당 그래프



#### 교착 상태 회피
스레드가 요구하고 사용할 자원에 대한 부가적인 정보를 미리 제공할 것을 요구한다.
추가적인 지식을 가지고, 운영체제는 각 요청을 위해 그 스레드가 기다려야 할지 않을지를 결정할 수 있다.
각 요구는 시스템이 현재 요청이 만족할 수 있는지, 또는 반드시 지연시켜야 하는지를 결정하기 위해, 현재 유용한 자원들과 각 스레드에 현재 할당된 자원들, 각 스레드의 미래 요청과 방출을 고려하도록 요구한다.
만약 시스템이 교착상태 예방/회피 알고리즘을 사용 않으면 교착 발생할 수 있다
교착상태를 무시하는것도 비용이 적게 드는 방법이다. 많은 시스템에서 교착상태는 드물게 발생하기 때문이다. 그래서 이를 복잡한 방법으로 처리하는 부가적인 비용이 그만한 가치가 없을 수도 있다.

라이브락과 같은 다른 라이브니스 조건으로부터 복구하는 데 사용되는 방법을 교착 상태로부터 복구하는 데 사용할 수 있다. 어떤 상황에서는 시스템이 라이브니스 장애로 고생하고 있지만 교착 상태에 있지 않을 수 있다.


#### 교착 상태 예방
교착상태의 4개 필요조건(상호배제, 비선점, 대기하며 점유, 순환점유) 중 적어도 하나가 성립하지 않도록 제한함.
1. 상호배제
* 적어도 하나의 자원은 공유가 불가능한 자원이어야 한다.
* 반면, 공유 가능한 자원들은 배타적인 접근을 요구하지 않으며, 따라서 교착 상태에 관련될 수 없다.
* 읽기-전용 파일이 공유 가능한 자원의 좋은 예이다.(여러 스레드가 읽기전용 open 하면 그들은 그 파일에 동시 접근을 허용한다)
* 하지만 어떤 자원은 근본적으로 공유가 불가능(mutex 락)

2. 점유하며 대기
* 점유하며 대기 조건이 발생 안하도록 하려면, 스레드가 자원요청할 때마다 다른 자원을 보유하지 않도록 보장해야한다.
* 우리가 사용할 수 있는 하나의 프로토콜은 각 스레드가 실행 시작하기 전에 모든 자원을 요청하고 할당해야 한다.
* 대안 프로토콜은 스레드가 자원을 전혀 갖고 있지 않을 때만 자원을 요청할 수 있게 허용한다. 스레드는 일부 자원을 요청하고, 사용할 수도 있다. 
* 스레드가 추가 자원 **요청**할 수 있으려면, 자신에게 할당된 모든 자원을 반드시 먼저 방출해야 한다.

* 단점1) 자원 할당되었지만 장기간 사용되지 않을 수 있어 자원 이용률 낮을 수 있다.
스레드는 전체 실행 시간 동안 뮤텍스 락이 할당될 수 있지만 짧은 기간만 필요할 수 있다.
* 단점2) 기아가 발생할 수 있다. 인기 있는 여러 개 자원이 필요한 스레드는 필요한 자원 중 적어도 하나는 항상 다른 스레드에 할당되므로 무한정 대기해야 할 수 있다

3. 비선점
* 할당된 자원이 선점되어야 한다로 비성립 만들기
* 만일 어떤 자원 점유하고 있는 스레드가 즉시 할당할 수 없는 다른 자원을 요청하면(즉, 스레드가 반드시 대기해야 한다면) 현재 점유하고 있는 모든 자원이 선점된다.
    * 즉, 이들 자원들이 묵시적으로 방출
    * 선점된 자원들은 그 스레드가 기다리고 있는 자원들의 리스트에 추가된다.
    * 스레드는 자신이 요청하고 있는 새로운 자원은 물론 이미 점유하였던 옛 자원들을 다시 획득할 수 있을 때만 다시 시작될 것이다.
* 대안으로, 한 스레드가 어떤 자원들을 요청하면, 우리는 이들이 사용 가능한지를 검사한다.
    * 만약 사용 가능하다면, 이들을 할당한다.
    * 이들이 사용 불가능하다면, 그 자원들이 추가의 자원을 위해 대기하고 있는 어떤 다른 스레드에 할당되어 있는지를 검사한다.
    * 만약 사용 가능하다면, 대기 중인 스레드로부터 원하는 자원을 선점해 이들을 요청하는 스레드에게 할당한다.