# 파일 시스템 인터페이스
## 1. 파일 개념
* 파일은 운영체제에 의하여 정의 구현되는 추상적인 자료형
* 파일은 논리 레코드의 연속 - 바이트, 행, 또는 복합적인 자료 항목 -> 운영체제에 의해 물리 장치들로 사상됨 (비휘발성)
* 운영체제는 다양한 레코드형을 사용자에게 제공 또는 사용자가 프로그램상에 정의하도록 해줌

### 파일 속성
: 이름, 식별자, 유형, 위치, 크기, 보호, 타임스탬프 & 사용자 식별

### 파일 연산
: 파일 생성, 파일 열기, 파일 쓰기, 파일 읽기, 파일 안에서의 위치 재설정(reposition - seek), 파일 삭제, 파일 절단(파일속성 그대로 & 파일 내용 지우기) 
- 대부분 파일 연산은 '탐색' -맨 처음 open() 시스템 콜
- os는 모든 열린 파일에 대한 정보 갖는 열린 파일 테이블(open-file table)을 유지
    - 파일연산이 요구되면 이 테이블에 대한 인덱스로 파일 지정하므로 '탐색' 연산 필요성 X
    - 파일이 더 사용되지 않으면 프로세스에 의해 닫히고 운영체제는 open-file table 을 제거하며, 락을 해제
- 대부분 시스템은 파일이 사용되기 전 먼저 open()시스템 콜을 호출하고 연다. 
    - open() 시스템 콜은 파일 이름 취하여 파일 이름으로 디렉터리 찾고 -> 디렉터리 항목을 열린 파일 테이블로 복사
    - open() 시스템 콜은 접근 모드 정보를 받을 수 있다(접근 모드 정보-생성, 읽기-전용, 읽기-쓰기, 덧붙이기-전용)
     - 이 모드를 파일의 권한과 대조
     - 만일 요구된 모드가 허용되면, 그 프로세스를 위해 파일을 연다.
    - open() 시스템 콜은 열린 파일 테이블의 항목에 대한 '포인터' 를 되돌려 준다. 
        - 실제 파일명 아닌 포인터를 입출력 연산에 사용해서 탐색과정 피하고 시스템 콜 인터페이스 단순화
- 여러 개의 프로세스가 동시에 파일 열 수 있는 환경에서 open()과 close() 연산 구현 복잡
    - 이유 : 파일을 관리하는 정보가 프로세스마다 따로 필요한 것도 있고, 모든 프로세스가 공유해야 하는 정보도 있기 때문에
    - 운영체제는 2단계 내부 테이블 - 프로세스별 테이블 & 범 시스템 테이블 사용
    - 프로세스별 테이블 (Process File Table)
        - 각 프로세스가 어떤 파일을 열었는지 기록
        - 이 파일을 어떻게 사용 중인지 기록 (읽기 전용인지, 쓰기 모드인지 등)
        - 현재 파일 포인터 위치(다음에 읽거나 쓸 위치) 저장
        - 이 테이블의 각 항목은 범 시스템 테이블의 항목을 가리킴
    - 범 시스템 테이블 : 프로세스에 독립적인 파일 자체에 대한 공통 정보 기록
        - 디스크상의 파일 위치, 접근 날짜, 파일 크기
    🔗 작동 방식
    - 어떤 프로세스가 처음으로 파일을 열면, 범 시스템 테이블에 해당 파일 정보가 생성됨.
    - 이후 다른 프로세스가 같은 파일을 열면, 새로 파일 정보를 만들지 않고 기존 범 시스템 테이블 항목을 가리키는 포인터만 추가함.
    - 이 구조 덕분에 여러 프로세스가 한 파일을 같이 쓰되, 포인터 위치는 따로 관리할 수 있음.
- 열린 파일 테이블은 연 프로세스 수를 가리키는 열린 계수를 각 파일에 연관해 두고 있다.
    - 파일 close()시 계수 감소, 계수 0 되었을 때, 파일은 '더는 사용되지 않음' -> 열린 파일 테이블로부터 제거
### 파일 락킹 기능
- 열린 파일을 락킹할 수 있는 기능
- 하나의 프로세스가 파일을 잠그고, 다른 프로세스들이 그것에 대한 접근을 막는 데 사용
- 파일 락은 여러 프로세스에 의해 사용되고 수정되는 시스템 로그파일에 ㅇ유용
- 공유 락 : 여러 프로세스가 동시에 락을 획득할 수 있다, 읽기 락과 비슷
- 배타적인 락 : 한 번에 한 프로세스만 락을 획득 , 쓰기 락과 비슷

- 강제적/권고적 파일 락
    - 강제적 락: 어떤 프로세스가 배타적 락 획득 시 os가 다른 프로세스가 접근하는 것을 방지함 -> 락 무결성을 안전하게 보장
    - 권고적 락: 다른 프로세스가 배타적 락 걸린 파일 접근을 막진 않고 파일에 접근하기 전에 락을 획득할 수 있도록 쓰여야 함. -> 락이 획득.해제되는 것에 대한 보장이 개발자 몫 

- 파일 락 사용 주의
    - 강제적 락 사용 시스템(윈도우) 개발시 파일에 접근할 때만 배타적 락 가지도록 해야함
    - 두개 이상의 프로세스가 파일 락 얻음으로써 생길 수 있는 교착 상태 상황 되지 않도록 대책 취해야 함.


### 파일 유형
- 운영체제가 파일 유형들을 인식하고 지원할 것인지 결정하기
- 파일 이름의 한 부분이 파일 유형을 나타내도록 하기(확장자)
- 응용 프로그램이 동작하는 파일에 대한 "힌트"

- 맥OS 에서 각 파일은 .app 와 같은 파일 유형
- 각 파일은 자신을 생성한 프로그램의 이름을 파일 속성으로 가진다.
- 이속성은 create()호출 중 운영체제에 의해 설정

- 매직넘버: 이진 파일 시작 부분, 파일의 데이터 유형을 나타낸다.

### 파일 구조
- 파일 유형 사용해서 파일의 내부 구조 형태 짐작할 수 있다.
- 실행파일 : os는 실행파일에 대하여 실행 파일이 메모리상 어느 위치에 적재되며, 초기에 실행가능한 명령어 위치 파악할 수 있는 구조 요구
- os가 여러 파일 구조 지원하는 경우, 운영체제 크기 커지고 관리 어려움

- ex) 아스키 텍스트 & 실행파일 두가지 파일 유형만 지원하는 시스템
    - 다른사람 무단 사용 방지 위해 암호화된 파일 사용하고자 함
    - 아스키 텍스트 파일이 아니라 보안을 위해 임의의 비트로 인코딩된 형태 -> 이진파일
    - 이것은 실행파일 형태가 아니므로 결국 os의 파일 유형 매커니즘에 반하는 에외 케이스 만들수 있음.
- 어떤 운체들은 파일 형태, 구조에 제한 안 둠.
- UNIX: 파일 단순히 8비트 바이트들의 단순한 집합. 시스템은 어떠한 목적으로도 자유롭게 파일 사용 -> 시스템 유연성 극대화. 
- 모든 운체들은 반드시 한가지 파일 구조는 지원해야 함 - 실행 파일 구조

### 파일 내부 구조
파일은 내부적으로 바이트(논리 레코드)들의 연속으로 저장된다.

디스크 I/O는 블록(물리 레코드) 단위로만 이루어진다.

하나의 블록에는 여러 개의 논리 레코드가 들어갈 수 있다.

UNIX에서는 파일을 단순히 바이트 스트림으로 보고, 각 바이트를 오프셋(시작부터 몇 번째 바이트) 으로 위치를 지정한다.

파일 시스템은 필요할 때 논리 레코드를 블록 단위로 포장(pack)하거나 풀어줌(unpack)

결국, 사용자가 파일을 바이트 (논리)단위로 읽고 쓰더라도, 실제로는 디스크에서 블록(물리) 단위로 I/O가 발생한다.

내부 단편화

- 디스크공간이 항상 블록단위로 할당, 각 파일의 마지막 블록의 일부는 낭비된다.
- 만일 한 블록이 512 바이트라면, 파일크기 1949 바이트일 경우 4블록(2048바이트) 할당되고 -> 마지막 99바이트낭비
이렇게 낭비되는 것을 내부 단편화(internal fragmentation)
- 블록크기 클수록 내부단편화 커진다.

## 2. 접근 방법
파일이 사용될 때 정보가 접근되어 메모리로 읽혀야 한다.
: 순차 접근, 직접 접근, 기타 접근 방법
- 순차 접근 : 읽기와 쓰기연산이 대부분 (파일 현재위치 포인터 (offset) 자동증가)

- 직접 접근 
    - 직접 접근 파일은 어떤 블록이라도 직접 엑세스 할 수 있다. 블록 14 읽고, 그다음 53, 그다음 블록 7 읽을 수 있다.
    - 파일은 고정 길이의 논리 레코드 집합으로 정의된다. 
    - 파일은 번호를 갖는 일련의 블록 또는 레코드로 간주한다.
    - 대규모 데잍터베이스 : 어떤 쿼리 들어오면 그 답을 수록하고 있는 블록을 알아내어 직접 정보를 읽는다.
    - 파일 연산이 블록번호 파라미터 포함해야 함 ex) read_next() 가 아닌 read(n)
    - 블록 번호 n은 파일의 시작을 0으로 보고 계산한 레코드의 위치(상대 블록 번호)
    - 상대적 블록번호 사용 위해서는 운영체제가 파일이 어디에 저장되어야 하는지를 결정해야 하고, 사용자가 자신의 파일이 아닌 부분에 접근하는 것을 막게 한다.
    - 시스템은 파일의 N번째 레코드 요청 처리?
        - 논리적 레코드 길이 L이라고 가정하면, N번째 레코드에 대한 요청은 파일의 L*(N)의 위치로부터 L byte에 대한 요청(N=0이면 첫번째)이 된다.

 - 기타 접근
    - 파일 색인(index) : 여러 부분에 대한 포인터 제공
    - 찾고자 하는 레코드 있으면 색인 찾아 그에 대응하는 포인터 얻는다. 그 다음 그 포인터 사용하여 파일 직접 접근하고, 원하는 레코드를 찾는다.
    1. 파일 구조 예시

        - 각 레코드 = UPC 코드(10자리) + 가격(6자리) → 총 16바이트 
        - 디스크 한 블록 = 1024바이트 
        - 한 블록에 들어갈 수 있는 레코드 수 = 1024 ÷ 16 = 64개 
        - 120,000개의 레코드를 저장
        - 필요한 블록 수 = 120,000 ÷ 64 = 약 2000블록
        - 파일 전체 크기 = 2000블록 × 1024바이트 = 약 2MB

    2. 검색 효율을 높이기 위해 정렬 + 인덱스 사용

        - 파일을 UPC 코드 순으로 정렬해 둔다.
        - **각 블록의 첫 번째 UPC 코드만** 따로 모아 인덱스를 만든다.
        - 인덱스에는 블록이 총 2000개니까 2000개의 항목이 생긴다.
        - 각 항목은 10자리(10바이트)이므로, 인덱스 전체 크기는 2000 × 10 = 20,000바이트(20KB) → 메모리에 올릴 수 있음.

    3. 검색 절차
        - 메모리에 있는 인덱스에서 이진 탐색으로 원하는 UPC가 들어 있을 블록을 찾는다.
        - 그 블록을 디스크에서 읽어온다.
        - 블록 안에서 순차 검색하여 정확한 레코드를 찾는다.

    - 파일이 크면 인덱스도 매우 커서 메모리에 못 들어가므로 그것 자체를 파일로 만들어준다.
    - primary index 파일은 2차 색인 파일의 포인터를 가지고, 다시 실제 자료 항목을 가리킨다
    - 항목 찾기 위해 1. 마스터 색인에서 이진탐색 하여 2차 색인 블록 번호 알아냄 2.2차색인을 이진탐색 하여 원하는 레코드 찾아내고, 이 블록을 순차적으로 탐색 
    - 이 방법으로 어떠한 레코드도 최대 2번의 직접 접근 읽기로 그 위치를 알아낼 수 있다.


# 3. 디렉터리 구조
* 심볼 테이블 : 디렉터리는 파일이름을 상응하는 파일 제어 블록으로 바꾸어 주는 심볼 테이블이다.
| 디렉터리 연산      | 설명                  | 리눅스 명령어                     |
| ------------ | ------------------- | --------------------------- |
| **파일 찾기**    | 특정 파일을 디렉터리에서 검색    | `find . -name "파일이름"`       |
| **파일 생성**    | 새로운 파일을 생성          | `touch 파일이름`                |
| **파일 삭제**    | 파일을 삭제              | `rm 파일이름`                   |
| **디렉터리 나열**  | 디렉터리 안의 파일 목록 출력    | `ls` 또는 `ls -l`             |
| **파일 재명명**   | 파일 이름 변경            | `mv 기존이름 새이름`               |
| **파일시스템 순회** | 디렉터리와 하위 디렉터리 전체 탐색 | `tree` (패키지 필요) 또는 `find .` |


1. 1단계 디렉터리
```
/ (루트)
 ├─ file1.txt
 ├─ file2.txt
 └─ file3.txt
```
2. 2단계 디렉터리
```
/ (MFD)
 ├─ userA/
 │   ├─ a1.txt
 │   └─ a2.txt
 └─ userB/
     ├─ b1.txt
     └─ b2.txt

```
3. 트리 구조 디렉터리
```
/ (루트)
 ├─ userA/
 │   ├─ docs/
 │   │   ├─ report.docx
 │   │   └─ memo.txt
 │   └─ images/
 │       └─ photo.png
 └─ userB/
     └─ music/
         └─ song.mp3
```

4. 비순환 그래프 디렉터리
* 트리 구조처럼 계층적으로 파일을 관리하지만, 하나의 파일이나 디렉터리를 여러 디렉터리에서 공유할 수 있음 (하드 링크)
* 단, 순환(Loop)이 없도록 제한한다.
* 파일을 여러 디렉터리에서 공유할 수 있어 중복 저장을 방지한다
* 같은 파일을 여러 경로에서 접근 가능.
```
/ (루트)
 ├─ userA/
 │   └─ report.docx
 └─ userB/
     └─ report.docx (userA/report.docx의 링크)

```
5. 일반 그래프 디렉터리
* 비순환 그래프 디렉터리에서 순환까지 허용한 구조. 즉, 파일이나 디렉터리가 서로를 참조해 무한 루프를 만들 수도 있음.
* 가비지 컬렉션(사용하지 않는 파일 삭제) 시 삭제 여부 판단이 매우 어려움.
```
/ (루트)
 ├─ dirA/
 │   └─ dirB/ (링크)
 │       └─ dirA/ (다시 dirA를 링크 → 순환 발생)
```

| 디렉터리 구조          | 리눅스에서의 구현 방식                                  | 관련 명령어                                   |
| ---------------- | --------------------------------------------- | ---------------------------------------- |
| **1단계 디렉터리**     | 모든 파일을 한 디렉터리에 넣음                             | `ls`, `touch`, `rm`                      |
| **2단계 디렉터리**     | 사용자별 홈 디렉터리 구조 (`/home/userA`, `/home/userB`) | `mkdir /home/userA`, `mkdir /home/userB` |
| **트리 구조 디렉터리**   | 디렉터리 안에 하위 디렉터리 생성 가능                         | `mkdir -p dirA/dirB/dirC`                |
| **비순환 그래프 디렉터리** | **하드링크(ln)** 를 사용해 여러 경로에서 같은 파일을 공유 (순환 X)   | `ln file1.txt dirA/file1_link`           |
| **일반 그래프 디렉터리**  | **심볼릭 링크(ln -s)** 를 사용하면 순환 구조도 가능            | `ln -s dirA dirB/link_to_A`              |
## 하드링크 vs. 심볼릭링크
| 구분              | 하드링크 (Hard Link)                                | 심볼릭 링크 (Symbolic Link)         |
| --------------- | ----------------------------------------------- | ------------------------------ |
| **동작 방식**       | 같은 **inode 번호**를 공유 → 원본 파일과 동일한 파일             | 원본 파일의 **경로(Path)** 를 가리키는 별칭  |
| **inode 공유 여부** | ✅ 공유 (같은 inode)                                 | ❌ 공유하지 않음 (새 inode 생성)         |
| **원본 삭제 시**     | 원본을 삭제해도 링크는 그대로 사용 가능 (inode 참조가 남아있으면 데이터 유지) | 원본을 삭제하면 링크가 **깨짐(Dead Link)** |
| **파일 시스템 제한**   | 같은 파일 시스템에서만 가능                                 | 다른 파일 시스템에도 가능                 |
| **디렉터리 링크**     | 기본적으로 불가능                                       | 가능 (단, 주로 root 권한 필요)          |
| **용도**          | 여러 이름으로 **같은 파일을 완전히 공유**                       | 파일이나 디렉터리의 **바로가기(Shortcut)**  |
| **명령어**         | `ln 원본 링크이름`                                    | `ln -s 원본 링크이름`                |


# 4. 보호(Protection)
* 정보는 물리적인 손상(신뢰성) 으로부터 , 부적절한 접근(보호) 로부터 안전해야함
    * 신뢰성 -> 파일 복사본에 의해 제공
    * 보호 -> 암호인증, 보조저장장치 암호화, 방화벽으로 네트워크 엑세스 보호
        - 다중 사용자 시스템에서 시스템에 대한 유효한 엑세스도 데이터에 대한 유효 엑세스만 허용하기 위해선 고급 기법 필요함.

1. 접근의 유형 - 통제된 접근
    - 읽기, 쓰기, 실행, 추가(파일끝 새 정보 추가), 삭제, 리스트(파일속성 이름 출력), 속성변경
2. 접근 제어 - 접근허용여부 결정
    - 여러 사용자별 각 파일 디렉터리에 대해 서로 다른 접근 필요
    - ACL(접근 제어 리스트) : 파일을 누가 어떤 연산 위해 사용할 수 있는지 기술
        - 그 사용자가 특정 파일 접근 요청 시 os는 그 파일의 ACL 검사하여 허용여부 결정.
    - ACL 길이 간소화를 위해, 사용자를 3가지로 분류 : 소유자, 그룹, 기타
    - Solaris 계열 OS에서는 ls -l 명령 결과에서 권한 부분 끝에 +가 붙으면,→ ACL이 추가로 설정되어 있음을 의미합니다.
    - ACL 설정/조회는 setfacl, getfacl 같은 별도 명령으로 수행한다.
    - 허가와 ACL이 상충할 때 우선권 부여 문제 "ACL 우선"
    - 명시적으로 권한 부여한 것이 명시되지 않은 것에 비해 우선권을 갖는다.
3. 다른 보호방법
- 각 파일에 접근할 때 암호 요구
- 기억할 암호 수 많아짐, 모든 파일에 대해 하나의 암호라면 알려지면 모든 파일이 취약해짐 (전무한 보호)
- 디렉터리마다 암호 요구
- directory protection : 디렉토리용 연산은 파일연산과 다르게 보호되어야 한다. 한 디렉터리 내에 파일 생성/ 제거하는 일 제어하기 원한다. 
- 때로 디렉터리 내부 파일의 존재여부와 이름을 아는 것 자체가 중요할 수 있다. 
- 사용자가 한 파일의 path name 제시하면, 그는 디렉터리와 파일을 둘다 접근할 수 있게 해야 한다. 
- 만일 한 파일이 여러개 path name 가지는 경우 한 사용자가 사용하는 path name 에 따라 서로 다른 엑세스 권한으로 이 파일에 접근할 수 있다.

# 5. 메모리 사상 파일
## 파일의 메모리 사상 기본 기법
- 파일에 엑세스 할때, 시스템콜 open() 말고 다른 방법
- 디스크 입출력을 메모리 참조 방식으로 대신할 수 있다.
    - : 프로세스의 가상 주소공간 일부를 관련된 파일에 할애하는 것.
🔑 핵심 개념
- 파일의 내용 → 프로세스의 가상 메모리 공간에 매핑

- 매핑된 영역에 접근하면 OS가 페이지 캐시를 통해 자동으로 디스크 입출력을 수행합니다.

- 즉, 개발자는 파일을 읽고 쓰는 코드를 작성할 필요 없이, 배열을 다루듯이 메모리에 접근하면 됨.

- 장점: 속도 향상 – 시스템콜 오버헤드가 줄어듦

- 간단한 프로그래밍 – 포인터로 메모리처럼 접근
- 여러 프로세스 간 공유 메모리로 사용 가능


## Windows API에서 공유 메모리
* windows API 로 공유메모리에 기록하는 생산자, 소비자



# 요약

* 운영체제의 가장 중요한 문제 : 논리적인 파일을 하드디스크/NVM장치와 같은 실제 저장장치에 어떻게 매핑시키냐?
* 보통 물리레코드 크기 =! 논리레코드 크기 , -> 논리 레코드를 물리 레코드에 연관시켜야 함 - 이 작업은 os 또는 사용자의 application 에서 할 수 있다
* 파일 시스템 내에서 파일 구조화하는 디렉터리 만드는 것이 유용하다. 
* 다중 사용자 시스템
    * 1단계 디렉터리는 모든 파일이 고유 이름 가져야 하므로 파일 명칭 부여 문제 유발
    * 2단계 디렉터리는 각 사용자에 대하여 독자적 디렉터리 할당하여 문제 해결
    * 디렉터리는 이름으로 파일 기록하고, 디스크 상에서의 파일의 위치, 길이, 형태, 소유자, 생성 시간, 마지막 사용 시간 등 정보를 포함함

* 2단계 확장 -> 트리 구조 디렉터리
    * 사용자가 자신의 파일 구성하기 위하여 서브 디렉터리 구성할 수 있게 해준다.
* 비순환 그래프 디렉터리 구조는 서브디렉터리와 파일의 공유 허용하지만, 탐색과 삭제 복잡
* 일반적인 디렉터리 구조는 디렉터리와 파일의 공유에 완전한 융통성 주는 대신, 사용되지 않는 디스크 공간 회수 위해 쓰레기 수집(Garbage Collection) 이 필요하다.

* 원격파일 시스템은 안정성, 성능 및 보안에 해결할 과제를 제시한다. 분산 정보 시스템은 클라이언트-서버가 상태 정보 공유하여 사용 및 엑세스를 관리할 수 있도록 사용자, 호스트 및 엑세스 정보를 유지관리한다.
* 파일은 대부분 컴퓨터 시스템에서 주요 정보 저장 수단이기 때문에 다중 사용자 시스템에서 파일 보호가 필요하다.
* 파일에 대한 접근은 읽기, 쓰기, 실행, 덧붙이기, 디렉터리 열거 등의 접근 유형에 따라 별도로 통제되어야 한다.
* 파일 보호는 암호, 접근 리스트 또는 특별한 임의 기법으로 구현될 수 있다.